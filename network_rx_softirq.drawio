<mxfile host="app.diagrams.net" modified="2021-01-13T09:10:20.403Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36" etag="GZT-Qb6bkLYAh1y2lf9S" version="14.1.9" type="github">
  <diagram id="ujBVOgP984la-8cFtETQ" name="Page-1">
    <mxGraphModel dx="1449" dy="643" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="Ofch4F5-wFthdu-f2mCN-1" value="软中断(SoftIRQ)" style="rounded=1;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="80" y="40" width="210" height="60" as="geometry" />
        </mxCell>
        <mxCell id="Ofch4F5-wFthdu-f2mCN-2" value="&lt;h3&gt;1. 软中断是什么&lt;/h3&gt;&lt;div&gt;内核的软中断系统是一种在硬中断处理上下文(驱动中)之外执行代码的机制。硬中 断处理函数执行时，&lt;/div&gt;&lt;div&gt;会屏蔽部分或全部(新的)硬中断。中断被屏蔽的时间越长，丢失事件的可能性也就越大。&lt;/div&gt;&lt;div&gt;所以所有耗时的操作都应该从硬中断处理逻辑中剥离出来，硬中断因此能尽可能快地执行，然后再重新打开硬中断。&lt;/div&gt;&lt;div&gt;可以把软中断系统想象成一系列内核线程(每个 CPU 一个)，这些线程执行针对不同事件注册的处理函数。&lt;/div&gt;&lt;div&gt;ksoftirqd/0这个内核线程,其表示这个软中断线程跑在CPU 0上&lt;/div&gt;&lt;div&gt;内核子系统能通过 open_softirq()注册软中断处理函数&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
          <mxGeometry x="320" y="20" width="450" height="230" as="geometry" />
        </mxCell>
        <mxCell id="Ofch4F5-wFthdu-f2mCN-3" value="&lt;h3&gt;2. ksoftirqd&lt;/h3&gt;&lt;div&gt;软中断对分担硬中断的工作量至关重要，因此软中断线程在内核启动的很早阶段就spawn出来&lt;/div&gt;&lt;div&gt;static struct smp_hotplug_thread softirq_threads = {&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; .store&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &amp;amp;ksoftirqd,&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; .thread_should_run&amp;nbsp; = ksoftirqd_should_run,&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; .thread_fn&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = run_ksoftirqd,&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; .thread_comm&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; = &quot;ksoftirqd/%u&quot;,&lt;/div&gt;&lt;div&gt;};&lt;/div&gt;&lt;div&gt;static __init int spawn_ksoftirqd(void)&lt;/div&gt;&lt;div&gt;{&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; register_cpu_notifier(&amp;amp;cpu_nfb);&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; BUG_ON(smpboot_register_percpu_thread(&amp;amp;softirq_threads));&lt;/div&gt;&lt;div&gt;}&lt;/div&gt;&lt;div&gt;early_initcall(spawn_ksoftirqd);&lt;/div&gt;&lt;div&gt;看到注册了两个回调函数: ksoftirqd_should_run和run_ksoftirqd。这两个函数都会从 kernel/smpboot.c 里调用，作为事件处理循环的一部分。&lt;/div&gt;&lt;div&gt;kernel/smpboot.c里面的代码首先调用 ksoftirqd_should_run 判断是否有 pending 的软 中断,&lt;/div&gt;&lt;div&gt;如果有就执行run_ksoftirqd,后者做一些bookeeping 工作，然后调用 __do_softirq&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
          <mxGeometry x="320" y="280" width="490" height="330" as="geometry" />
        </mxCell>
        <mxCell id="Ofch4F5-wFthdu-f2mCN-4" value="&lt;h3&gt;3. __do_softirq&lt;/h3&gt;&lt;div&gt;__do_softirq 做的几件事情：&lt;/div&gt;&lt;div&gt;判断哪个softirq被 pending&lt;/div&gt;&lt;div&gt;计算softirq时间，用于统计&lt;/div&gt;&lt;div&gt;更新softirq执行相关的统计数据&lt;/div&gt;&lt;div&gt;执行pending softirq的处理函数&lt;/div&gt;&lt;div&gt;查看CPU利用率时，si字段对应的就是softirq，度量（从硬中断转移过来的）软中断的CPU使用量。&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
          <mxGeometry x="320" y="640" width="480" height="180" as="geometry" />
        </mxCell>
        <mxCell id="Ofch4F5-wFthdu-f2mCN-5" value="&lt;h3&gt;4. 监控&lt;/h3&gt;&lt;div&gt;软中断的信息可以从 /proc/softirqs 读取&lt;/div&gt;&lt;div&gt;$ cat /proc/softirqs&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CPU0&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CPU1&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CPU2&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CPU3&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; NET_TX:&amp;nbsp; &amp;nbsp;15774435&amp;nbsp; &amp;nbsp; &amp;nbsp;779806&amp;nbsp; &amp;nbsp; &amp;nbsp;733217&amp;nbsp; &amp;nbsp; &amp;nbsp;749512&lt;/div&gt;&lt;div&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; NET_RX: 1671622615 1257853535 2088429526 2674732223&lt;/div&gt;&lt;div&gt;NET_RX一行显示的是软中断在CPU间的分布。如果分布非常不均匀，那某一列的 值就会远大于其他列&lt;/div&gt;&lt;div&gt;这预示着下面要介绍的 Receive Packet Steering / Receive Flow Steering 可能会派上用场&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;align=left;" vertex="1" parent="1">
          <mxGeometry x="320" y="850" width="480" height="180" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
